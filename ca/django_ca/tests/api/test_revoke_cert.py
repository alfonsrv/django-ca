# This file is part of django-ca (https://github.com/mathiasertl/django-ca).
#
# django-ca is free software: you can redistribute it and/or modify it under the terms of the GNU General
# Public License as published by the Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# django-ca is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along with django-ca. If not, see
# <http://www.gnu.org/licenses/>.

"""Test the revoking certificates via the API."""
import typing
from http import HTTPStatus
from typing import Any

from django.test import TestCase
from django.urls import reverse_lazy
from django.utils import timezone

from freezegun import freeze_time

from django_ca import ca_settings
from django_ca.models import Certificate
from django_ca.tests.api.mixins import APITestCaseMixin
from django_ca.tests.base import certs, timestamps
from django_ca.utils import x509_name

if typing.TYPE_CHECKING:
    from django.test.client import _MonkeyPatchedWSGIResponse as HttpResponse


class RevokeCertificateTestCase(APITestCaseMixin, TestCase):
    """Test the revoking certificates via the API."""

    path = reverse_lazy(
        "django_ca:api:revoke_certificate",
        kwargs={"serial": certs["root"]["serial"], "certificate_serial": certs["root-cert"]["serial"]},
    )
    required_permission = (Certificate, "revoke_certificate")
    load_certs = ("root-cert",)

    def setUp(self) -> None:
        super().setUp()
        cert = certs["root-cert"]
        self.cert.profile = ca_settings.CA_DEFAULT_PROFILE
        self.cert.save()
        self.expected_response = {
            "autogenerated": False,
            "created": self.iso_format(self.cert.created),
            "not_after": self.iso_format(self.cert.expires),
            "not_before": self.iso_format(self.cert.valid_from),
            "pem": cert["pub"]["pem"],
            "profile": self.cert.profile,
            "revoked": True,
            "serial": cert["serial"],
            "subject": x509_name(cert["subject"]).rfc4514_string(),
            "updated": self.iso_format(self.cert.updated),
        }

    def default_request(self, *args: Any, **kwargs: Any) -> "HttpResponse":
        if not args:
            args = ({},)
        kwargs["content_type"] = "application/json"
        return self.client.post(self.path, *args, **kwargs)

    @freeze_time(timestamps["everything_valid"])
    def test_revoke_view(self) -> None:
        """Test an ordinary certificate revocation."""
        self.expected_response["updated"] = self.iso_format(timezone.now())

        response = self.default_request()
        self.assertEqual(response.status_code, HTTPStatus.OK, response.json())
        self.assertEqual(response.json(), self.expected_response, response.json())

        self.cert.refresh_from_db()
        self.assertTrue(self.cert.revoked)
        self.assertEqual(self.cert.revoked_reason, "unspecified")
        self.assertIsNone(self.cert.compromised)

    @freeze_time(timestamps["everything_valid"])
    @freeze_time(timestamps["everything_valid"])
    def test_revoke_with_parameters(self) -> None:
        """Test an ordinary certificate revocation."""
        now = timezone.now()
        self.expected_response["updated"] = self.iso_format(now)

        response = self.default_request({"reason": "affiliationChanged", "compromised": self.iso_format(now)})

        self.assertEqual(response.status_code, HTTPStatus.OK, response.json())
        self.assertEqual(response.json(), self.expected_response, response.json())

        self.cert.refresh_from_db()
        self.assertTrue(self.cert.revoked)
        self.assertEqual(self.cert.revoked_reason, "affiliation_changed")
        self.assertEqual(self.cert.compromised, now)

    @freeze_time(timestamps["everything_valid"])
    def test_revoked_certificate_fails(self) -> None:
        """Test that revoking a revoked certificate fails."""
        self.cert.revoke()

        response = self.default_request()
        self.assertEqual(response.status_code, HTTPStatus.BAD_REQUEST, response.json())
        self.assertEqual(response.json(), {"detail": "The certificate is already revoked."}, response.json())

    @freeze_time(timestamps["everything_expired"])
    def test_cannot_revoke_expired_certificate(self) -> None:
        """Test that we cannot revoke a certificate if it is expired."""
        response = self.default_request()
        self.assertEqual(response.status_code, HTTPStatus.NOT_FOUND, response.json())
        self.assertEqual(response.json(), {"detail": "Not Found"}, response.json())

        self.cert.refresh_from_db()
        self.assertFalse(self.cert.revoked)  # cert is still not revoked (just expired)

    @freeze_time(timestamps["everything_valid"])
    def test_certificate_not_found(self) -> None:
        """Test response when a certificate was not found."""
        Certificate.objects.all().delete()
        response = self.default_request()
        self.assertEqual(response.status_code, HTTPStatus.NOT_FOUND, response.json())
        self.assertEqual(response.json(), {"detail": "Not Found"}, response.json())

    @freeze_time(timestamps["everything_valid"])
    def test_disabled_ca(self) -> None:
        """Test that certificates for a disabled can *not* be viewed."""
        self.ca.enabled = False
        self.ca.save()

        response = self.default_request()
        self.assertEqual(response.status_code, HTTPStatus.NOT_FOUND, response.json())
        self.assertEqual(response.json(), {"detail": "Not Found"}, response.json())
