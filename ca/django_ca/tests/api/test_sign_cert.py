# This file is part of django-ca (https://github.com/mathiasertl/django-ca).
#
# django-ca is free software: you can redistribute it and/or modify it under the terms of the GNU General
# Public License as published by the Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# django-ca is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along with django-ca. If not, see
# <http://www.gnu.org/licenses/>.

"""Test the signing certificates via the API."""
import typing
from datetime import timedelta
from http import HTTPStatus
from typing import Any

from cryptography.hazmat.primitives import hashes

from django.test import TestCase
from django.urls import reverse_lazy
from django.utils import timezone

from freezegun import freeze_time

from django_ca import ca_settings
from django_ca.models import Certificate
from django_ca.tests.api.mixins import APITestCaseMixin
from django_ca.tests.base import certs, override_tmpcadir, timestamps

if typing.TYPE_CHECKING:
    from django.test.client import _MonkeyPatchedWSGIResponse as HttpResponse


class SignCertificateTestCase(APITestCaseMixin, TestCase):
    """Test the signing certificates via the API."""

    path = reverse_lazy("django_ca:api:sign_certificate", kwargs={"serial": certs["root"]["serial"]})
    required_permission = (Certificate, "sign_certificate")

    def setUp(self) -> None:
        super().setUp()
        cert = certs["root-cert"]
        self.expected_response = {
            "autogenerated": False,
            "created": self.iso_format(timestamps["everything_valid"]),
            "not_after": self.iso_format(timestamps["everything_valid"] + ca_settings.CA_DEFAULT_EXPIRES),
            "not_before": self.iso_format(timestamps["everything_valid"]),
            "pem": cert["pub"]["pem"],
            "profile": ca_settings.CA_DEFAULT_PROFILE,
            "revoked": False,
            "serial": cert["serial"],
            "subject": "CN=api.example.com,OU=Django CA Testsuite,O=Django CA,L=Vienna,ST=Vienna,C=AT",
            "updated": self.iso_format(timestamps["everything_valid"]),
        }

    def default_request(self, *args: Any, **kwargs: Any) -> "HttpResponse":
        if not args:
            args = ({"csr": certs["root-cert"]["csr"]["pem"], "subject": "CN=api.example.com"},)

        kwargs["content_type"] = "application/json"
        return self.client.post(self.path, *args, **kwargs)

    @override_tmpcadir()
    @freeze_time(timestamps["everything_valid"])
    def test_sign_certificate(self) -> None:
        """Test a minimal certificate signing."""

        response = self.default_request()
        self.assertEqual(response.status_code, HTTPStatus.OK, response.json())

        # Get certificate to update expected response
        cert: Certificate = Certificate.objects.get(ca=self.ca, cn="api.example.com")
        self.expected_response["pem"] = cert.pub.pem
        self.expected_response["serial"] = cert.serial

        self.assertEqual(response.json(), self.expected_response, response.json())
        self.assertEqual(cert.profile, ca_settings.CA_DEFAULT_PROFILE)
        self.assertFalse(cert.autogenerated)
        self.assertEqual(cert.algorithm, self.ca.algorithm)

    @override_tmpcadir()
    @freeze_time(timestamps["everything_valid"])
    def test_sign_certificate_with_parameters(self) -> None:
        """Test signing with parameters."""

        expires = timezone.now() + timedelta(days=73)
        self.expected_response["autogenerated"] = True
        self.expected_response["profile"] = "server"
        self.expected_response["not_after"] = self.iso_format(expires)
        response = self.default_request(
            {
                "csr": certs["root-cert"]["csr"]["pem"],
                "subject": "CN=api.example.com",
                "autogenerated": True,
                "profile": "server",
                "expires": self.iso_format(expires),
                "algorithm": "SHA3/384",
            }
        )

        self.assertEqual(response.status_code, HTTPStatus.OK, response.json())

        # Get certificate to update expected response
        cert: Certificate = Certificate.objects.get(ca=self.ca, cn="api.example.com")
        self.expected_response["pem"] = cert.pub.pem
        self.expected_response["serial"] = cert.serial

        self.assertEqual(response.json(), self.expected_response, response.json())
        self.assertEqual(cert.profile, "server")
        self.assertTrue(cert.autogenerated)
        self.assertIsInstance(cert.algorithm, hashes.SHA3_384)

    @freeze_time(timestamps["everything_expired"])
    def test_expired_ca(self) -> None:
        """Test that you can *not* sign a certificate for an expired CA."""

        response = self.default_request()
        self.assertEqual(response.status_code, HTTPStatus.NOT_FOUND, response.json())
        self.assertEqual(response.json(), {"detail": "Not Found"}, response.json())

    @freeze_time(timestamps["everything_valid"])
    def test_disabled_ca(self) -> None:
        """Test that you cannot sign a certificate for a disabled CA."""
        self.ca.enabled = False
        self.ca.save()

        response = self.default_request()
        self.assertEqual(response.status_code, HTTPStatus.NOT_FOUND, response.json())
        self.assertEqual(response.json(), {"detail": "Not Found"}, response.json())
