# This file is part of django-ca (https://github.com/mathiasertl/django-ca).
#
# django-ca is free software: you can redistribute it and/or modify it under the terms of the GNU General
# Public License as published by the Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# django-ca is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along with django-ca. If not, see
# <http://www.gnu.org/licenses/>.

"""Test the signing certificates via the API."""
import ipaddress
import typing
from datetime import timedelta
from http import HTTPStatus
from typing import Any

from cryptography import x509
from cryptography.hazmat.primitives import hashes
from cryptography.x509.oid import ExtendedKeyUsageOID, ExtensionOID, NameOID

from django.test import TestCase
from django.urls import reverse_lazy
from django.utils import timezone

from freezegun import freeze_time

from django_ca import ca_settings, constants
from django_ca.models import Certificate
from django_ca.tests.api.mixins import APITestCaseMixin
from django_ca.tests.base import certs, dns, ip, override_tmpcadir, rdn, timestamps, uri

if typing.TYPE_CHECKING:
    from django.test.client import _MonkeyPatchedWSGIResponse as HttpResponse


class SignCertificateTestCase(APITestCaseMixin, TestCase):
    """Test the signing certificates via the API."""

    path = reverse_lazy("django_ca:api:sign_certificate", kwargs={"serial": certs["root"]["serial"]})
    required_permission = (Certificate, "sign_certificate")

    def setUp(self) -> None:
        super().setUp()
        cert = certs["root-cert"]
        self.expected_response = {
            "autogenerated": False,
            "created": self.iso_format(timestamps["everything_valid"]),
            "not_after": self.iso_format(timestamps["everything_valid"] + ca_settings.CA_DEFAULT_EXPIRES),
            "not_before": self.iso_format(timestamps["everything_valid"]),
            "pem": cert["pub"]["pem"],
            "profile": ca_settings.CA_DEFAULT_PROFILE,
            "revoked": False,
            "serial": cert["serial"],
            "subject": "CN=api.example.com,OU=Django CA Testsuite,O=Django CA,L=Vienna,ST=Vienna,C=AT",
            "updated": self.iso_format(timestamps["everything_valid"]),
        }

    def default_request(self, *args: Any, **kwargs: Any) -> "HttpResponse":
        if not args:
            args = ({"csr": certs["root-cert"]["csr"]["pem"], "subject": "CN=api.example.com"},)

        kwargs["content_type"] = "application/json"
        return self.client.post(self.path, *args, **kwargs)

    @override_tmpcadir()
    @freeze_time(timestamps["everything_valid"])
    def test_sign_certificate(self) -> None:
        """Test a minimal certificate signing."""

        response = self.default_request()
        self.assertEqual(response.status_code, HTTPStatus.OK, response.json())

        # Get certificate to update expected response
        cert: Certificate = Certificate.objects.get(ca=self.ca, cn="api.example.com")
        self.expected_response["pem"] = cert.pub.pem
        self.expected_response["serial"] = cert.serial

        self.assertEqual(response.json(), self.expected_response, response.json())
        self.assertEqual(cert.profile, ca_settings.CA_DEFAULT_PROFILE)
        self.assertFalse(cert.autogenerated)
        self.assertEqual(cert.algorithm, self.ca.algorithm)

    @override_tmpcadir()
    @freeze_time(timestamps["everything_valid"])
    def test_sign_certificate_with_parameters(self) -> None:
        """Test signing with parameters."""

        expires = timezone.now() + timedelta(days=73)
        self.expected_response["autogenerated"] = True
        self.expected_response["profile"] = "server"
        self.expected_response["not_after"] = self.iso_format(expires)
        response = self.default_request(
            {
                "csr": certs["root-cert"]["csr"]["pem"],
                "subject": "CN=api.example.com",
                "autogenerated": True,
                "profile": "server",
                "expires": self.iso_format(expires),
                "algorithm": "SHA3/384",
            }
        )

        self.assertEqual(response.status_code, HTTPStatus.OK, response.json())

        # Get certificate to update expected response
        cert: Certificate = Certificate.objects.get(ca=self.ca, cn="api.example.com")
        self.expected_response["pem"] = cert.pub.pem
        self.expected_response["serial"] = cert.serial

        self.assertEqual(response.json(), self.expected_response, response.json())
        self.assertEqual(cert.profile, "server")
        self.assertTrue(cert.autogenerated)
        self.assertIsInstance(cert.algorithm, hashes.SHA3_384)

    @override_tmpcadir()
    @freeze_time(timestamps["everything_valid"])
    def test_sign_certificate_with_extensions(self) -> None:
        """Test signing certificates with extensions."""

        response = self.default_request(
            {
                "csr": certs["root-cert"]["csr"]["pem"],
                "subject": "CN=api.example.com",
                "extensions": {
                    "authority_information_access": {
                        "value": {
                            "issuers": ["http://api.issuer.example.com"],
                            "ocsp": ["http://api.ocsp.example.com"],
                        },
                    },
                    "certificate_policies": {
                        "value": [
                            {"policy_identifier": "1.1.1"},
                            {
                                "policy_identifier": "1.3.3",
                                "policy_qualifiers": [
                                    "A policy qualifier as a string",
                                    {
                                        "explicit_text": "An explicit text",
                                        "notice_reference": {
                                            "organization": "some org",
                                            "notice_numbers": [1, 2, 3],
                                        },
                                    },
                                ],
                            },
                        ]
                    },
                    "crl_distribution_points": {
                        "value": [
                            {"full_name": ["http://api.crl1.example.com"]},
                            {
                                "full_name": ["http://api.crl2.example.com"],
                                "crl_issuer": ["http://api.crl2.example.com"],
                                "reasons": ["keyCompromise"],
                            },
                            {"relative_name": "/CN=example.com"},
                        ]
                    },
                    "extended_key_usage": {"value": ["serverAuth", "1.2.3"]},
                    "freshest_crl": {"value": [{"full_name": ["http://api.freshest-crl.example.com"]}]},
                    "key_usage": {"value": ["keyEncipherment"]},
                    "ocsp_no_check": {},
                    "subject_alternative_name": {
                        "critical": not constants.EXTENSION_DEFAULT_CRITICAL[
                            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
                        ],
                        "value": ["DNS:example.com", "IP:127.0.0.1"],
                    },
                    "tls_feature": {"value": ["OCSPMustStaple"]},
                },
            }
        )
        self.assertEqual(response.status_code, HTTPStatus.OK, response.json())

        # Get certificate to update expected response
        cert: Certificate = Certificate.objects.get(ca=self.ca, cn="api.example.com")
        self.expected_response["pem"] = cert.pub.pem
        self.expected_response["serial"] = cert.serial

        self.assertEqual(response.json(), self.expected_response, response.json())
        self.assertEqual(cert.profile, ca_settings.CA_DEFAULT_PROFILE)
        self.assertFalse(cert.autogenerated)
        self.assertEqual(cert.algorithm, self.ca.algorithm)

        # Test extensions
        extensions = cert.x509_extensions

        # Test Authority Information Access extension
        self.assertEqual(
            extensions[ExtensionOID.AUTHORITY_INFORMATION_ACCESS],
            self.authority_information_access(
                ca_issuers=[uri("http://api.issuer.example.com")], ocsp=[uri("http://api.ocsp.example.com")]
            ),
        )

        # Test Certificate Policies extension
        self.assertEqual(
            extensions[ExtensionOID.CERTIFICATE_POLICIES],
            self.certificate_policies(
                x509.PolicyInformation(
                    policy_identifier=x509.ObjectIdentifier("1.1.1"), policy_qualifiers=None
                ),
                x509.PolicyInformation(
                    policy_identifier=x509.ObjectIdentifier("1.3.3"),
                    policy_qualifiers=[
                        "A policy qualifier as a string",
                        x509.UserNotice(
                            notice_reference=x509.NoticeReference(
                                organization="some org", notice_numbers=[1, 2, 3]
                            ),
                            explicit_text="An explicit text",
                        ),
                    ],
                ),
            ),
        )

        # Test CRL Distribution Points extension
        self.assertEqual(
            extensions[ExtensionOID.CRL_DISTRIBUTION_POINTS],
            x509.Extension(
                oid=ExtensionOID.CRL_DISTRIBUTION_POINTS,
                critical=False,
                value=x509.CRLDistributionPoints(
                    [
                        self.distribution_point(full_name=[uri("http://api.crl1.example.com")]),
                        self.distribution_point(
                            full_name=[uri("http://api.crl2.example.com")],
                            crl_issuer=[uri("http://api.crl2.example.com")],
                            reasons=frozenset([x509.ReasonFlags.key_compromise]),
                        ),
                        self.distribution_point(relative_name=rdn([(NameOID.COMMON_NAME, "example.com")])),
                    ]
                ),
            ),
        )

        # Test Extended Key Usage extension
        self.assertEqual(
            extensions[ExtensionOID.EXTENDED_KEY_USAGE],
            self.extended_key_usage(ExtendedKeyUsageOID.SERVER_AUTH, x509.ObjectIdentifier("1.2.3")),
        )

        # Test Freshest CRL extension
        self.assertEqual(
            extensions[ExtensionOID.FRESHEST_CRL],
            x509.Extension(
                oid=ExtensionOID.FRESHEST_CRL,
                critical=False,
                value=x509.FreshestCRL(
                    [
                        self.distribution_point(full_name=[uri("http://api.freshest-crl.example.com")]),
                    ]
                ),
            ),
        )

        # Test Key Usage extension
        self.assertEqual(extensions[ExtensionOID.KEY_USAGE], self.key_usage(key_encipherment=True))

        # Test OCSPNoCheck extension
        self.assertEqual(extensions[ExtensionOID.OCSP_NO_CHECK], self.ocsp_no_check())

        # Test Subject Alternative Name extension
        self.assertEqual(
            extensions[ExtensionOID.SUBJECT_ALTERNATIVE_NAME],
            self.subject_alternative_name(
                dns("example.com"),
                ip(ipaddress.IPv4Address("127.0.0.1")),
                dns("api.example.com"),
                critical=True,
            ),
        )

        # Test TLSFeature extension
        self.assertEqual(
            extensions[ExtensionOID.TLS_FEATURE], self.tls_feature(x509.TLSFeatureType.status_request)
        )

    @override_tmpcadir()
    @freeze_time(timestamps["everything_valid"])
    def test_sign_certificate_with_subject_alternative_name(self) -> None:
        """Test signing certificates with an additional subject alternative name."""

        response = self.default_request(
            {
                "csr": certs["root-cert"]["csr"]["pem"],
                "subject": "CN=api.example.com",
                "extensions": {
                    "subject_alternative_name": {
                        "critical": not constants.EXTENSION_DEFAULT_CRITICAL[
                            ExtensionOID.SUBJECT_ALTERNATIVE_NAME
                        ],
                        "value": ["DNS:example.com", "IP:127.0.0.1"],
                    },
                },
            }
        )
        self.assertEqual(response.status_code, HTTPStatus.OK, response.json())

        # Get certificate to update expected response
        cert: Certificate = Certificate.objects.get(ca=self.ca, cn="api.example.com")
        self.expected_response["pem"] = cert.pub.pem
        self.expected_response["serial"] = cert.serial

        self.assertEqual(response.json(), self.expected_response, response.json())
        self.assertEqual(cert.profile, ca_settings.CA_DEFAULT_PROFILE)
        self.assertFalse(cert.autogenerated)
        self.assertEqual(cert.algorithm, self.ca.algorithm)

        extensions = cert.x509_extensions
        # Test Subject Alternative Name extension
        self.assertEqual(
            extensions[ExtensionOID.SUBJECT_ALTERNATIVE_NAME],
            self.subject_alternative_name(
                dns("example.com"),
                ip(ipaddress.IPv4Address("127.0.0.1")),
                dns("api.example.com"),
                critical=True,
            ),
        )

    @freeze_time(timestamps["everything_valid"])
    def test_crldp_with_full_name_and_relative_name(self) -> None:
        """Test sending a CRL Distribution point with a full_name and a relative_name"""
        response = self.default_request(
            {
                "csr": certs["root-cert"]["csr"]["pem"],
                "subject": "CN=api.example.com",
                "extensions": {
                    "crl_distribution_points": {
                        "value": [
                            {
                                "full_name": ["http://api.crl1.example.com"],
                                "relative_name": "/CN=example.com",
                            },
                        ]
                    },
                },
            }
        )
        self.assertEqual(response.status_code, HTTPStatus.UNPROCESSABLE_ENTITY, response.json())
        self.assertEqual(
            response.json(),
            {
                "detail": [
                    {
                        "loc": [
                            "body",
                            "data",
                            "extensions",
                            "crl_distribution_points",
                            "value",
                            0,
                            "__root__",
                        ],
                        "msg": "Distribution point must contain either full_name OR relative_name.",
                        "type": "value_error",
                    }
                ]
            },
        )

    @freeze_time(timestamps["everything_valid"])
    def test_crldp_with_no_full_name_or_relative_name(self) -> None:
        """Test sending a CRL Distribution point with neither a full name nor a relative name."""
        response = self.default_request(
            {
                "csr": certs["root-cert"]["csr"]["pem"],
                "subject": "CN=api.example.com",
                "extensions": {
                    "crl_distribution_points": {
                        "value": [
                            {},
                        ]
                    },
                },
            }
        )
        self.assertEqual(response.status_code, HTTPStatus.UNPROCESSABLE_ENTITY, response.json())
        self.assertEqual(
            response.json(),
            {
                "detail": [
                    {
                        "loc": [
                            "body",
                            "data",
                            "extensions",
                            "crl_distribution_points",
                            "value",
                            0,
                            "__root__",
                        ],
                        "msg": "Distribution point must contain one of full_name OR relative_name.",
                        "type": "value_error",
                    }
                ]
            },
        )

    @freeze_time(timestamps["everything_valid"])
    def test_with_invalid_key_usage(self) -> None:
        """Test sending an invalid key usage."""
        response = self.default_request(
            {
                "csr": certs["root-cert"]["csr"]["pem"],
                "subject": "CN=api.example.com",
                "extensions": {
                    "key_usage": {"value": ["unknown"]},
                },
            }
        )
        self.assertEqual(response.status_code, HTTPStatus.UNPROCESSABLE_ENTITY, response.json())
        self.assertEqual(
            response.json(),
            {
                "detail": [
                    {
                        "loc": ["body", "data", "extensions", "key_usage", "value"],
                        "msg": "unknown: Invalid key usage.",
                        "type": "value_error",
                    }
                ]
            },
        )

    @freeze_time(timestamps["everything_expired"])
    def test_expired_ca(self) -> None:
        """Test that you can *not* sign a certificate for an expired CA."""

        response = self.default_request()
        self.assertEqual(response.status_code, HTTPStatus.NOT_FOUND, response.json())
        self.assertEqual(response.json(), {"detail": "Not Found"}, response.json())

    @freeze_time(timestamps["everything_valid"])
    def test_private_key_unavailable(self) -> None:
        """Test the error when no private key is available."""
        response = self.default_request()
        self.assertEqual(response.status_code, HTTPStatus.BAD_REQUEST, response.json())
        self.assertEqual(
            response.json(),
            {"detail": "This certificate authority can not be used to sign certificates via the API."},
            response.json(),
        )

    @freeze_time(timestamps["everything_valid"])
    def test_disabled_ca(self) -> None:
        """Test that you cannot sign a certificate for a disabled CA."""
        self.ca.enabled = False
        self.ca.save()

        response = self.default_request()
        self.assertEqual(response.status_code, HTTPStatus.NOT_FOUND, response.json())
        self.assertEqual(response.json(), {"detail": "Not Found"}, response.json())
